#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const ejs = require('ejs');
const upperCamelCase = require('uppercamelcase');
const mkdir = require('mkdir-recursive').mkdir;

const commander = require('commander');

// Templates

const rootPath = path.join(__dirname, '..');
const templatesPath = path.join(__dirname, '..', 'scaffold');
const sourcePath = path.join(__dirname, '..', 'src');
const testPath = path.join(__dirname, '..', 'test');


function checkFileExisting(name, filePath) {
  return new Promise((resolve, reject) => {
    fs.stat(filePath, err => {
      if (err) {
        return resolve();
      }

      const relativePath = path.relative(rootPath, filePath);

      return reject(`Error: file '${relativePath}' already exists`);
    });
  });
}

function checkDirectoryExisting(filePath) {
  const directoryPath = path.dirname(filePath);

  return new Promise(resolve => mkdir(directoryPath, () => resolve()));
}

function readTemplate(name) {
  const fileName = path.join(templatesPath, `${ name }.ejs`);

  return new Promise((resolve, reject) => {
    fs.readFile(fileName, (err, data) => {
      return err ? reject(err) : resolve(data.toString());
    });
  });
}

function renderTemplate(template, data) {
  const content = ejs.render(template, data);

  return Promise.resolve(content);
}

function saveTemplate(content, outputPath) {
  return new Promise((resolve, reject) => {
    fs.writeFile(outputPath, content, err => {
      return err ? reject(err) : resolve(content);
    });
  });
}

function generateFile(name, data, outputPath) {
  return checkFileExisting(name, outputPath)
    .then(() => checkDirectoryExisting(outputPath))
    .then(() => readTemplate(name))
    .then(template => renderTemplate(template, data))
    .then(content => saveTemplate(content, outputPath))
    .catch(err => console.log(err)); // eslint-disable-line
}

function extractName(scaffoldName) {
  const pathElements = scaffoldName.split('/');
  const name = pathElements[pathElements.length - 1];

  return upperCamelCase(name);
}

// Commands

commander.version(require('../package').version);

commander.usage('[generator] [name]');

commander
  .command('component [name]')
  .alias('c')
  .description('generate class component')
  .action(component => {
    const outputPath = path.join(sourcePath, 'components', `${component}.js`);
    const testOutputPath = path.join(testPath, 'components', `${component}.js`);
    const name = extractName(component);

    generateFile('component', { name }, outputPath);
    generateFile('component-test', { name, path: component }, testOutputPath);
  });

commander
  .command('pure-component [name]')
  .alias('p')
  .description('generate pure component')
  .action(component => {
    const outputPath = path.join(sourcePath, 'components', `${component}.js`);
    const testOutputPath = path.join(testPath, 'components', `${component}.js`);
    const name = extractName(component);

    generateFile('pure-component', { name }, outputPath);
    generateFile('component-test', { name, path: component }, testOutputPath);
  });

commander.parse(process.argv);
